\section{Preliminaries}
\subsection{Data Flow Essentials}
Many algorithms can be conveniently formulated as a data flow --- a directed graph whose nodes represent operations performed on data, and whose edges represent the flow of data between such operators. This representation is especially handy for streaming systems, where the data is continuously fed into the system. Most of the streaming data processing systems in use today make use of data flows as the primary programming mechanism. Users express their programs in the form of several operators that are connected together, forming the \ti{logical data flow}. The system then turns this logical data flow into a \ti{physical data flow} by distributing the computation across \ti{workers}. Workers represent physical processing units such as the cores of a processor, or individual machines in a network. \\

\imagefigure[dataflow]{images/dataflow.pdf}{An illustration of the difference between logical (top) and physical (bottom) data flows. The illustration is based on Timely's model, where each worker (thread) has a whole copy of the dataflow graph. Each worker executes all operators according to a scheduling strategy and exchanges data with other workers asynchronously. Other systems like Flink and Heron instead have each worker execute a single operator.}

The data to be processed by each operator is distributed to each worker by the system, though the precise mechanisms of this vary with each system. Often data-parallelism is employed wherein the data is partitioned into disjoint sets, and each worker is assigned one set of this data. After the worker has completed the operator's work, the generated output data is passed on to the next operator and might be redistributed across the workers.

\subsection{Timely Dataflow}
Timely\cite{timely} is a system written in Rust based on research initially proposed in Naiad\cite{naiad}. Timely offers a dataflow based processing framework, where a dataflow is composed of a possibly cyclic graph of operators. Each operator can receive data from previous operators through input edges in the graph, and send data to other operators through output edges. Each edge denotes the logical flow of data between operators. In the physical data flow the edges are turned into communication channels between workers to allow data-parallelism. \\

Timely tracks progress of the dataflow computation through ``epochs'' --- rounds of input data that are associated with a logical timestamp. These timestamps are required to implement a partial order, which is used to infer information about the progress of an operator. An important part of this inference is the notion of closing an epoch: when an epoch is closed, no more input may arrive for it. Operators can request to be notified when specific epochs are closed, and can thus reason about when they have the full picture of the data. As a consequence of this, data before the closure of an epoch can arrive out of order, which typically improves performance as it lowers synchronisation constraints. The tracking of the epoch closure is called the ``frontier''. \\

The permission of cycles in the dataflow graph is achieved through ``scopes''. Any cycle must be encapsulated by such a scope. Each scope extends the timestamp by another dimension that tracks the progress within that scope. When the scope receives notification that an epoch has closed, it then continues processing until all inner epochs have been closed as well, at which point it can advance the frontier itself and propagate the information to the operators after the scope as well. \\

While the physical exchange of data is handled by Timely itself, data is only exchanged if specified to be by the operators. This allows the implementer of an operator to decide whether it makes sense to re-distribute the processing of the data. For instance, a keyed reduction would profit from having the data set partitioned over the workers according to the keys. A simple map on the other hand would not profit from having its data bucketed over the workers first.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% TeX-engine: luatex
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
